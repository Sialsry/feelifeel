# 자바스크립트 배열, 함수, 실행컨텍스트

## 자바스크립트의 참조 타입
> object, array, Map, Set ,,

## 자바스크립트의 메모리
> call stack과 heap이라는 메모리 영역이 있음
> 원시타입은 call stack에 저장이 되고
> 참조타입은 heap메모리에 저장이 된다.

- 원시타입: 불변성을 가지고 새로운 데이터가 재할당되면 이전의 주소를 새로운 값의 주소로 변경하고 이전 주소는 이후에 해제된다.

- 참조타입: 주소를 가리키는 주소의 값이 있고 값을 변경할 때 heap메모리에서 참조되고 있는 주소의 값이 변경된다.
원시타입과 다르게 변수의 크기가 동적으로 변할 수 있다.

## 배열의 문법

```js
[예약어] [변수명] = []; // 배열을 표현하는 구문[]

// 리스트의 형태를 표현할 때
// 다른 언어와 다르게 자바스크립트의 배열은 동적인 타입이 모두 할당될 수 있다.

const arr = [1, "2", true, undefined, null, {}]; // 자바스크립트의 배열의 타입은 정해져있지 않고 동적인 타입을 모두 할당할 수 있다.
// 자바스크립트의 배열은 객체라고 보면 된다.
// 이중 배열 (유사배열)

const arr = [1, 2, 3];
// index를 표현할 때 0부터 시작한다.
// 0에서부터 숫자를 세어나가면 된다.

// 이전에 배웠던 객체의 형태
const object = {
    name : "soon"
}
// 객체 안의 값을 호출할 때
object.name === "soon";
object["soon"]

// 배열의 값을 호출할 때 인덱스 번호로 접근한다.
arr[0] === 1;
arr[1] === 2;
arr[2] === 3;
arr[3] = 4; // 할당하는 방법

// 배열에 값을 추가할 때
// 배열의 맨 뒤나 앞에 새로운 값을 추가할 때
// push라는 메서드를 사용해서 

arr.push(4); // 객체 안에 키 값으로 포함되어있는 것은 메서드
// 맨 뒤에 4라는 값 추가


// 배열의 개수 확인하는 키값
arr.length // 배열의 길이를 호출하는 키
arr.length === 4

for(let i = 1; i <= 100; i++){
    arr.push(i);
}

// 컨텐츠를 만드는데 제목이 5개가 필요하다. 
for(let i = 1; i <= 5; i++){
    arr.push(i + "번째 제목");
}

["1번째 제목", "2번째 제목", ... "5번째 제목"]

for(let i = 1; i <= 100; i++){
    const object = {
        title : i + "번째 제목",
        content : i + "번째 컨텐츠"
    }
    arr.push(object);
}

[{title : "번째 제목", content : "1번째 컨텐츠"}, ...]

// 배열은 여러가지 갯수가 많은 데이터를 다룰 때 용이하다.
// 배열은 여러가지의 값을 접근할 때 용이하기 때문에 우리가 많은 양의 데이터를 배열에 담아서 사용한다.
arr[2] === {title : "3번째 제목", content: "3번째 컨텐츠"}

for(let i = 0; i < arr.length; i++) {
    // 예를 들어서 dom제어
    myTag.InnerHTML 
}

```



### 참조 타입의 깊은 복사 얕은 복사
- 얕은 복사: 값을 복사하는 방식에서 참조타입의 주소를 복사하는 방식
- 깊은 복사: 값을 복사하는 방식에서 참조타입의 값을 복사하는 방식

```js

const a = [1];
const b = [1];
a === b



    const a = [1];
    const b = [1];
    // 참조 타입은 주소를 가리키는 주소
    // 값은 heap이라는 공간에 저장이 되고
    // 주소를 변수가 가리키게 된다.
console.log(a === b); // 주소가 같냐? 다름





const c = a;
// a의 변수의 주소를 복사해서 사용한 것
// 할당된 것이 주소
// 같은 주소를 바라보고 있기 때문에 c에서 가리키는 주소의 값을 변경하면 a의 바라보고 있는 주소의 값이 바뀐다.
// 얕은 복사

console.log(c === a);







```